
class entity {
bool taken{ false };
public:
void take() { taken = true; }
void release() { taken = false; }
bool taken() const { return taken; }
// ...
};
constexpr int N = ...;
// entities is where the entity objects live. We did
// not allocate them dynamically, but if we had we would
// have used unique_ptr<entity> as this will be the
// single last point of use for these objects
array<entity,N> entities;
class nothing_left{};
// this function returns a non-owning pointer (Chapter 6
// will cover more ergonomic options than a raw pointer)
entity * borrow_one() {
if(auto p = find_if(begin(entities), end(entities),
[](auto && e) { return !e.taken(); };
p != end(entities)) {
p->take();
return &(*p); // non-owning pointer
}
throw nothing_left{};
}

constexpr int N = ...;

constexpr int N = ...;: This declares a constexpr (compile-time constant) integer variable named N. The constexpr keyword ensures that the value of
N is known at compile time. The ... means that the specific value of N is not shown in this snippet but would be defined elsewhere in the code.
This N likely represents the total number of entity objects that will be created.

// entities is where the entity objects live...: This is a comment explaining the purpose of the next line, 
stating that the entities variable is where the entity objects will be stored.
array<entity,N> entities;: This declares an array named entities that can hold N objects of type entity. 
This means that N entity objects will be created and stored contiguously in memory when this line is executed. 
This is a fixed-size array, allocated on the stack. The comment mentions that if dynamic allocation were used (e.g., with new), unique_ptr<entity> 
would be a good choice for managing the memory to prevent leaks.

class nothing_left{};
class nothing_left{};: This defines an empty class called nothing_left. This class is likely used as an exception type.
It doesn't contain any members but serves as a marker to signal that no more entities are available.

// this function returns a non-owning pointer (Chapter 6
// will cover more ergonomic options than a raw pointer)
entity * borrow_one() {
if(auto p = find_if(begin(entities), end(entities),
[](auto && e) { return !e.taken(); };
p != end(entities)) {
p->take();
return &(*p); // non-owning pointer
}
throw nothing_left{};
}


entity * borrow_one() { ... }: This defines a function named borrow_one() that returns a pointer (entity *) to an entity object. The comment clarifies that this is a 
non-owning pointer, meaning the function does not take responsibility for managing the lifetime of the pointed-to object.
if(auto p = find_if(begin(entities), end(entities), [](auto && e) { return !e.taken(); }; p != end(entities)) { ... }: This is the core logic for finding an available 
entity. Let's break it down:
auto p = find_if(begin(entities), end(entities), [](auto && e) { return !e.taken(); });: This uses the std::find_if algorithm to search the entities array for an entity 
that is not currently taken.
begin(entities) and end(entities): These return iterators to the beginning and end of the entities array, respectively. find_if uses these to know where to search.
[](auto && e) { return !e.taken(); }: This is a lambda expression that defines a predicate (a function that returns true or false). The lambda takes an entity object e 
(using universal reference auto &&) and returns true if e.taken() is false (meaning the entity is available), and false otherwise.
auto p = ...;: The find_if function returns an iterator to the first element that satisfies the predicate. If no such element is found, it returns end(entities). 
The auto keyword automatically deduces the type of the iterator p.
p != end(entities): This checks if find_if actually found an available entity. If p is not equal to end(entities), it means an available entity was found.
p->take();: If an available entity was found (inside the if block), this line calls the take() method on the found entity (pointed to by p). This marks the entity as 
"taken."
return &(*p);: This returns a pointer to the "taken" entity.
*p: Dereferences the iterator p to get the entity object itself.
&(*p): Takes the address of the entity object, resulting in a pointer to the entity. This is a raw pointer.
throw nothing_left{};: If find_if did not find an available entity (the if condition was false), this line throws an exception of type nothing_left. This signals to 
the calling code that there are no more entities available to be borrowed.
In Summary:

The borrow_one() function attempts to find an available entity (one where taken is false). If it finds one, it marks it as taken and returns a pointer to it. 
If no available entities are found, it throws a nothing_left exception. The returned pointer is non-owning, meaning the caller is responsible for not using it after 
the entities array goes out of scope (or is modified in a way that the entity might be released).

Important Note: As the code comment states, using raw pointers like this can be error-prone. Modern C++ often favors smart pointers (like unique_ptr or shared_ptr) 
to manage memory and ownership more safely.

==============================================================================================================================================================

// ...
// dynamically create an X or something derived from
// X and return it without risk of a leak
unique_ptr<X> factory(args);
// pass-by-value which means in practice pass-by-movement
// since unique_ptr is uncopiable
unique_ptr<X> borrowing(unique_ptr<X>);
// pass-by-reference to allow mutating the pointee. In
// practice, X* would be a better choice here
void possible_mutation(unique_ptr<X>&);
// pass by reference-to-const to consult the pointee but
// not mutate it. In practice, prefer const X* here
void consult(const unique_ptr<X>&);
// sink() consumes the object passed as argument : gets
// in, never gets out. This could use pass-by-value but
// intent is probably clearer with a rvalue-reference
void sink(unique_ptr<X> &&);
==============================================================================================================================================================================
A unique_ptr<T> object is non-copyable, as its copy constructor and copy assignment member
functions are marked as deleted. at’s why g() in the rst example of the Type unique_ptr section
takes its argument by reference – g() shares the pointee with the caller but does not take ownership of it. We could also have expressed g() as taking X* as an argument, 
with the contemporary acceptance
that function arguments that are raw pointers are meant to model using a pointer but without
owning it:
#include <memory>
class X {
// ...
};
std::unique_ptr<X> f();
void g(X*);
void h() {
// we could write std::unique_ptr<X> instead of auto
auto p = f();
g(p.get());
} // p implicitly releases the pointed-to X object here
unique_ptr<T> is also movable – a moved-from unique_ptr<T> behaves like a null pointer, as the
movement for this type semantically implements a transfer of ownership. is makes it simpler to
implement various types that need to manage resources indirectly.
=================================================================================================================================================================================

std::string_view:

It's a really useful feature introduced in C++17.  Here's a breakdown of what it is, why you'd use it, and some examples.

What is std::string_view?

std::string_view is a lightweight, non-owning view of a contiguous sequence of characters.  Think of it as a way to look at a portion of a string without copying the string data itself.  
It's essentially a pointer to a character sequence along with a size.

Why use std::string_view?

Efficiency: The biggest advantage is avoiding unnecessary string copies. When you pass a std::string by value to a function, a copy of the entire string is created. 
std::string_view avoids this overhead, making it much faster when you only need to read string data.
Flexibility: It can refer to substrings of std::string objects, C-style strings (character arrays), or any other contiguous character sequences.
Read-Only: std::string_view doesn’t provide methods for modifying the underlying string data. This helps prevent accidental modifications to the original string.
Const Correctness: It naturally encourages const-correctness (good practice!).
How to use it (with examples):

#include <iostream>
#include <string>
#include <string_view>

void print_substring(std::string_view str) {
  std::cout << "Substring: " << str << std::endl;
  std::cout << "Length: " << str.length() << std::endl;
}

int main() {
  std::string my_string = "Hello, world!";

  // Create a string_view from a std::string
  std::string_view view1 = my_string;
  print_substring(view1);

  // Create a string_view from a substring
  std::string_view view2 = my_string.substr(7, 5); // "world"
  print_substring(view2);

  // Create a string_view from a C-style string
  const char* c_string = "This is a C-string.";
  std::string_view view3 = c_string;
  print_substring(view3);

  return 0;
}

O/p:


Substring: Hello, world!
Length: 13
Substring: world
Length: 5
Substring: This is a C-string.
Length: 19


Explanation:

print_substring takes a std::string_view as input. Notice no copying happens when you pass view1, view2, or view3 to this function.
my_string.substr(7, 5) creates another std::string_view representing a portion of the original string.
We initialize view3 directly from a const char*.
Important Considerations:

Lifetime: The std::string_view doesn't own the data. Therefore, the underlying string data must remain valid for the lifetime of the std::string_view.
If the underlying string is deallocated, the std::string_view will become a dangling reference. Be very careful about this, especially when working with temporary strings.
Modification: You can't modify the string through a std::string_view.

==================================================================================================================================================================================

#include <memory>
template <class T>

bool point_to_same(const std::unique_ptr<T> &p0,
const std::unique_ptr<T> &p1) {
return p0 == p1;
}
template <class T>
bool have_same_value(const std::unique_ptr<T> &p0,
const std::unique_ptr<T> &p1) {
return p0 && p1 && *p0 == *p1;
}
#include <cassert>
int main() {
// two distinct pointers to objects with same value
std::unique_ptr<int> a{ new int { 3 } };
std::unique_ptr<int> b{ new int { 3 } };
assert(point_to_same(a, a) && have_same_value(a, a));
assert(!point_to_same(a, b) && have_same_value(a, b));
}

sizeof(unique_ptr<T>)==sizeof(T*) with a few exceptions that will be
discussed later in this chapter. is means that there’s generally no cost in terms of memory space to
using a smart pointer instead of a raw pointer. In other words, by default, the only state found in a
unique_ptr<T> object is T*.
