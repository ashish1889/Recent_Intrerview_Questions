pair<id,count>  -  store in set, lesser count then higher priority
point()  - 5 radius
x2 + y2 =r2



#include <iostream>
#include <set>

// Define a struct to represent the pair
struct Pair {
    int id;
    int count;

    // Constructor to initialize the pair
    Pair(int id, int count) : id(id), count(count) {}
};

// Custom comparator to sort pairs based on count in descending order
struct Compare {
    bool operator()(const Pair& a, const Pair& b) const {
        return a.count > b.count;
    }
};

int main() {
    // Create a set with the custom comparator
    std::set<Pair, Compare> pairSet;

    // Insert pairs into the set
    pairSet.insert(Pair(1, 5));
    pairSet.insert(Pair(2, 3));
    pairSet.insert(Pair(3, 8));
    pairSet.insert(Pair(4, 2));
    pairSet.insert(Pair(5, 6));

    // Print the pairs in the set (sorted by count in descending order)
    for (const auto& pair : pairSet) {
        std::cout << "ID: " << pair.id << ", Count: " << pair.count << std::endl;
    }

    return 0;
}


ID: 3, Count: 8
ID: 5, Count: 6
ID: 1, Count: 5
ID: 2, Count: 3
ID: 4, Count: 2
=====================================================================================================================================
Here if it is asked that if count is equal then the one having smaller value of id will come first-


#include <iostream>
#include <set>

// Define a struct to represent the pair
struct Pair {
    int id;
    int count;

    // Constructor to initialize the pair
    Pair(int id, int count) : id(id), count(count) {}
};

// Custom comparator to sort pairs based on count in descending order
struct Compare {
    bool operator()(const Pair& a, const Pair& b) const {
        if(a.count == b.count)
        return a.id < b.id;
        return a.count > b.count;
    }
};

int main() {
    // Create a set with the custom comparator
    std::set<Pair, Compare> pairSet;

    // Insert pairs into the set
    pairSet.insert(Pair(1, 5));
    pairSet.insert(Pair(2, 3));
    pairSet.insert(Pair(3, 5));
    pairSet.insert(Pair(4, 2));
    pairSet.insert(Pair(5, 5));

    // Print the pairs in the set (sorted by count in descending order)
    for (const auto& pair : pairSet) {
        std::cout << "ID: " << pair.id << ", Count: " << pair.count << std::endl;
    }

    return 0;
}

O/p:


ID: 1, Count: 5
ID: 3, Count: 5
ID: 5, Count: 5
ID: 2, Count: 3
ID: 4, Count: 2

========================================================================================================================================

#include <iostream>
#include <set>

int main() {
    // Create a set to store the pairs
    std::set<std::pair<int, int>, std::greater<std::pair<int, int>>> pairSet;

    // Insert pairs into the set
    pairSet.insert({5, 1});
    pairSet.insert({3, 2});
    pairSet.insert({8, 3});
    pairSet.insert({2, 4});
    pairSet.insert({6, 5});

    // Print the pairs in the set (sorted by count in descending order)
    for (const auto& pair : pairSet) {
        std::cout << "ID: " << pair.second << ", Count: " << pair.first << std::endl;
    }

    return 0;
}


ID: 3, Count: 8
ID: 5, Count: 6
ID: 1, Count: 5
ID: 2, Count: 3
ID: 4, Count: 2



#include <iostream>
#include <set>

int main() {
    // Create a set to store the pairs
    std::set<std::pair<int, int>> pairSet;

    // Insert pairs into the set
    pairSet.insert({1, 5});
    pairSet.insert({2, 3});
    pairSet.insert({3, 8});
    pairSet.insert({4, 2});
    pairSet.insert({5, 6});

    // Print the pairs in the set (sorted by id in ascending order)
    for (const auto& pair : pairSet) {
        std::cout << "ID: " << pair.first << ", Count: " << pair.second << std::endl;
    }

    return 0;
}


ID: 1, Count: 5
ID: 2, Count: 3
ID: 3, Count: 8
ID: 4, Count: 2
ID: 5, Count: 6


#include <iostream>
#include <cmath>
using namespace std;

// Function to draw a circle
void drawCircle(int radius) {
    int x, y;
    for (y = -radius; y <= radius; y++) {
        for (x = -radius; x <= radius; x++) {
            if (x * x + y * y == radius * radius) {
                cout << "* ";
            } else {
                cout << "  ";
            }
        }
        cout << endl;
    }
}

int main() {
    int radius;
    cout << "Enter the radius of the circle: ";
    cin >> radius;
    drawCircle(radius);
    return 0;
}


Enter the radius of the circle: 5
          *           
    *           *     
  *               *   
                      
                      
*                   * 
                      
                      
  *               *   
    *           *     
          *           

========================================================================================================================================================================

class A{}
 
class B{
unique_ptr<A> a;
}
 
 
running function{
unique_ptr<A> x;
B.a = move(x);
}


Program-

#include <iostream>
#include <memory>
using namespace std;

class A{
    public:
    A(){
        cout<<"A() Constructor called"<<endl;
    }
    ~A(){
        cout<<"~A() Destructor  called"<<endl;
    }
};

class B{
    
    public:
    unique_ptr<A> a;
    B(){
        cout<<"B() Constructor called"<<endl;
    }
    ~B(){
        cout<<"~B() Destructor  called"<<endl;
    }
};

int main()
{
    unique_ptr<A> x = make_unique<A>();
    B b;
    b.a = move(x);
    if(x == nullptr)
    cout<<"move nulled"<<endl;
    cout<<"Check before exit"<<endl;
    //std::cout<<"Hello World";

    return 0;
}


O/p-


A() Constructor called
B() Constructor called
move nulled
Check before exit
~B() Destructor  called
~A() Destructor  called

==================================================================================================================================================================================================


#include <string>
#include <iostream>
#include <format>
struct X {
std::string s;
X(std::string_view s) : s{ s } {
std::cout << std::format("X::X({})\n", s);
}
~X(){
std::cout << std::format("~X::X() for {}\n", s);
}
};
X glob { "glob" };
void g() {
X xg{ «g()» };
}
int main() {
X *p0 = new X{ "p0" };
[[maybe_unused]] X *p1 = new X{ "p1" }; // will leak
X xmain{ "main()" };
g();
delete p0;
// oops, forgot delete p1
}


When executed, that program will print the following:
X::X(glob)
X::X(p0)
X::X(p1)
X::X(main())
X::X(g())
~X::X() for g()
~X::X() for p0
~X::X() for main()
~X::X() for glob


[[maybe_unused]] X *p1 = new X{ "p1" }; // will leak: This line dynamically allocates memory for another object of type X using new, 
initializes it with the string "p1", and assigns the pointer to p1. The [[maybe_unused]] attribute indicates that the variable p1 might 
not be used, and the comment suggests that this object will cause a memory leak because its memory is not deallocated.

X(std::string_view s) : s{ s } {: This line declares a constructor for the struct X. The constructor takes a std::string_view parameter s and initializes the member variable s with it.

std::cout << std::format("X::X({})\n", s);: This line prints a message to the console indicating that the constructor of X has been called, along with the string that was passed to it.

X glob { "glob" };: This line creates a global object of type X named glob, initialized with the string "glob".

void g() {X xg{ "g()" }; }: This line declares a function g that creates a local object of type X named xg, initialized with the string "g()".

==========================================================================================================================================================================

class B; // forward declaration: there will be a class B
         // at some point in the future
void f(B*); // fine, we know what B is, even if we don't
            // know the details yet, and all object
            // addresses are of the same size

// class D : B {}; // oops! To know what a D is, we have
                   // to know how big a B is and what a
                   // B object contains since a D is a B

In that example, trying to de ne the D class would not compile. is is because in order to create a D
object, the compiler needs to reserve enough space for a D object, but a D object is also a B object, and as
such we cannot know the size of a D object without knowing the size of a B object.

============================================================================================================================================================================

char c;
// a char occupies precisely one byte of storage, per
// standard wording
static_assert(sizeof c == 1); // for objects parentheses
// are not required
static_assert(sizeof(c) == 1); // ... but you can use them
static_assert(sizeof(char) == 1); // for types, parentheses
// are required
struct Tiny {};
// all C++ types occupy non-zero bytes of storage by
// definition, even if they are "empty" like type Tiny
static_assert(sizeof(Tiny) > 0);
In the preceding example, the Tiny class is empty because it has no data member. A class could have
member functions and still be empty. Empty classes that expose member functions are very commonly
used in C++.
A C++ object always occupies at least one byte of storage, even in the case of empty classes such as
Tiny. at’s because if an object’s size was zero, that object could be at the same memory location as its
immediate neighbor, which would be somewhat hard to reason about.
===============================================================================================================================================================================

e size reported by operator sizeof for objects of type signed char, unsigned char and char is 1, and the same
goes for sizeof(std::byte) as each of these types can be used to represent a single byte.
Expressions sizeof(short)>=sizeof(char) and sizeof(int)>=sizeof(short) will hold on all platforms,
which means that there might be cases where sizeof(char) and sizeof(int) are both 1. In terms of width (i.e., bits
used in the value representation) of fundamental types, the C++ standard limits itself to stating the minimum width for each type.
e list can be found at [wg21.link/tab:basic.fundamental.width].
As we have already said, expression sizeof(T)>0 holds for any type T. In C++, there are no zero-sized objects, not even
objects of empty classes.
e size occupied by an object of any struct or class cannot be less than the sum of the size of its data members (but there
are caveats).

=================================================================================================================================================================================

class X {};
class Y {
X x;
};
int main() {
static_assert(sizeof(X) > 0);
static_assert(sizeof(Y) == sizeof(X)); // <-- here
}
e line marked <-- here might be intriguing. Why would sizeof(Y) be equal to sizeof(X) if every
Y object contains an X object? Remember that sizeof(X) is greater than 0 even though X is an empty
class because every C++ object has to occupy at least one byte of storage. However, in the case of Y,
which is not an empty class, each Y object already occupies storage due to its x data member. ere’s no
reason to somewhat artificially add storage space to objects of that type.

===================================================================================================================================================================================
class X {
char c;
};
class Y {
X x;
};
int main() {
static_assert(sizeof(X) == sizeof(char)); // <-- here
static_assert(sizeof(Y) == sizeof(X)); // <-- here too
}
e same reasoning applies again: an object of type X occupies the same amount of storage space as its
only data member (of type char), and an object of type Y occupies the same amount of storage space as
its only data member (of type X).
===================================================================================================================================================================================
class X { };
class Y {
X x;
char c;
};
int main() {
static_assert(sizeof(Y) >= sizeof(char) + sizeof(X));
}
is is the rule we mentioned earlier but expressed formally for a speci c type. In this situation,
supposing that sizeof(X)being equal to 1 is highly probable, one could even reasonably expect that
sizeof(Y)would be equal to the sum of sizeof(char)and sizeof(X).
====================================================================================================================================================================================

class X { };
class Y : X { // <-- private inheritance
char c;
};
int main() {
static_assert(sizeof(Y) == sizeof(char)); // <-- here
}

We moved from having an object of class X being a data member of Y to X being a base class of Y. is
has an interesting consequence: since the base class X is empty, and since we know from de nition that
objects of the derived class Y will occupy at least one byte of storage, the base class can be attened into
the derived class for Y objects. is is a useful optimization called the empty base optimization. You
can reasonably expect compilers to perform this optimization in practice, at least in the case of single
inheritance relationships.
Note that since the presence of an X in a Y is an implementation detail, not something that participates
in the interface of class Y, we used private inheritance in this example. e empty base optimization
would apply with public or protected inheritance too, but in this case, private inheritance preserves
the fact that the X part of a Y is something that only the Y knows about.

=====================================================================================================================================================================================

Since C++20, if you think composition would be more appropriate than inheritance to describe the
relation between two classes such as X and Y, you can mark a data member as [[no_unique_address]]
to inform the compiler that this member, if it is an object of an empty class, does not have to occupy
storage within the enclosing object. Compilers are not forced to comply, since attributes can be
ignored, so make sure to verify that your chosen compilers implement this before writing code that
relies on this:
class X { };
class Y {
char c;
[[no_unique_address]] X x;
};
int main() {
static_assert(sizeof(X) > 0);
static_assert(sizeof(Y) == sizeof(char)); // <-- here
}


