The following function properly allocates memory for a two-­dimensional array:

char** allocateCharacterBoard(size_t xDimension, size_t yDimension)
{
char** myArray { new char*[xDimension] }; // Allocate first dimension
for (size_t i { 0 }; i < xDimension; ++i) {
myArray[i] = new char[yDimension];
// Allocate ith subarray
}
return myArray;
}


Similarly, when you want to release the memory associated with a multidimensional free store-­based
array, the array delete[] syntax will not clean up the subarrays on your behalf. Your code to release
an array should mirror the code to allocate it, as in the following function:
void releaseCharacterBoard(char**& myArray, size_t xDimension)
{
for (size_t i { 0 }; i < xDimension; ++i) {
delete [] myArray[i];
// Delete ith subarray
myArray[i] = nullptr;
}
delete [] myArray;
// Delete first dimension
myArray = nullptr;
}

In new code, you should use the C++ Standard Library containers such as std::array and vector. For example, use vector<T> for a one-­dimensional dynamic array. For a two-­dimensional dynamic array, you could use
vector<vector<T>>, and similar for higher dimensions.

char* scaryPointer { (char*)7 };

This C++ line, char* scaryPointer { (char*)7 };, declares a character pointer named scaryPointer and initializes it to point to a specific memory address: 7. 
Explanation of the Line
char* scaryPointer: This declares a pointer named scaryPointer that is designed to hold the memory address of a single character or the beginning of a character array.
{ ... }: This uses C++11 uniform initialization syntax.
(char*)7: This is a cast operation. The integer value 7 is explicitly converted into a pointer type (char*). The pointer is therefore assigned the absolute memory address 0x7 (or just 7 in decimal). 
Pitfalls Associated with It
Initializing a pointer to a fixed, low-value memory address like this is fraught with danger in modern programming environments. 
Accessing Invalid Memory (Undefined Behavior): Address 7 is almost certainly not a valid memory location that your application is allowed to read from or write to [1, 2].
Operating System Reservations: Memory addresses near the beginning of the address space (often called the "zero page") are typically reserved by the operating system to 
catch accidental dereferences of NULL pointers or similar errors [1].

Segmentation Faults/Access Violations: Attempting to read from or write to this address (e.g., via *scaryPointer = 'a';) will likely cause your program to crash immediately with a 
segmentation fault or an access violation error, as the OS intervenes to protect system memory [1, 2].
Platform Dependence: The behavior is entirely dependent on the specific system architecture and operating system.
In some embedded systems with no OS, address 7 might be a perfectly valid location, perhaps a control register for a peripheral [1, 2].
On a standard PC (Linux, Windows, macOS), this address is inaccessible to user-level programs. Code relying on this kind of pointer manipulation is not portable [1, 2].
Lack of Purpose (In Modern C++): In standard application development, there is rarely a legitimate reason to manually hardcode an absolute memory address like this. Pointers should point to 
memory dynamically allocated by the program (using new or malloc), or to the address of an existing variable in the program's valid memory space. 
In summary, this line creates a pointer that points into forbidden territory, making it an excellent example of a "scary pointer" that will almost certainly lead to program crashes if used.


Casting with Pointers
Because pointers are just memory addresses (or arrows to somewhere), they are somewhat weakly
typed. A pointer to an XML document is the same size as a pointer to an integer. The compiler lets
you easily cast any pointer type to any other pointer type using a C-­style cast:
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
Of course, using the resulting pointer can result in catastrophic run-­time errors. A static cast offers a
bit more safety. The compiler refuses to perform a static cast on pointers to unrelated data types:
Document* documentPtr { getDocument() };
char* myCharPtr { static_cast<char*>(documentPtr) };// BUG! Won't compile


Instead of passing a C-­style array directly to a function, it is recommended for the function to have a parameter of type std::span, “Standard Library Containers.” span wraps a pointer to an array and its size!


void doubleInts(int* theArray, size_t size)
{
for (size_t i { 0 }; i < size; ++i) { theArray[i] *= 2; }
}
The caller of this function can pass a stack-­based or free store-­based array. In the case of a free store-­ based array, the pointer already exists and is passed by value into the function. In the case of a stack-­
based array, the caller can pass the array variable, and the compiler automatically treats the array variable as a pointer to the array, or you can explicitly pass the address of the first element. All three
forms are shown here:
size_t arrSize { 4 };
int* freeStoreArray { new int[arrSize]{ 1, 5, 3, 4 } };
doubleInts(freeStoreArray, arrSize);
delete [] freeStoreArray;
freeStoreArray = nullptr;
int stackArray[] { 5, 7, 9, 11 };
arrSize = std::size(stackArray);
// Since C++17, requires <array>
//arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-­
C++17, see Ch1
doubleInts(stackArray, arrSize);
doubleInts(&stackArray[0], arrSize);

The parameter-­passing semantics of arrays is uncannily similar to that of pointers, because the compiler treats an array as a pointer when it is passed to a function. A function that takes an array as
an argument and changes values inside the array is actually changing the original array, not a copy. Just like a pointer, passing an array effectively mimics pass-­by-­reference functionality because what
you really pass to the function is the address of the original array, not a copy. The following implementation of doubleInts() changes the original array even though the parameter is an array, not
a pointer:
void doubleInts(int theArray[], size_t size)
{
for (size_t i { 0 }; i < size; ++i) { theArray[i] *= 2; }
}
Any number between the square brackets after theArray in the function prototype is simply ignored.
The following three versions are identical:
void doubleInts(int* theArray, size_t size);
void doubleInts(int theArray[], size_t size);
void doubleInts(int theArray[2], size_t size);


For now, it is enough to know that wide strings support Unicode characters to represent, for example, Japanese strings. The wchar_t type is a character type that can accommodate such Unicode characters, and it is usually
bigger than a char; i.e., it’s more than one byte. To tell the compiler that a string literal is a wide-­string literal, prefix it with an L. For example, suppose you have the following wide string:
const wchar_t* myString { L"Hello, World" };


In C++, size_t is an unsigned integer type used to represent the size of objects in bytes and counts of elements. It is guaranteed to be large enough to hold the size of any object that the system's architecture can handle. 
Key Characteristics
Unsigned: It can only represent non-negative values (zero or positive). This makes sense for sizes and counts, which cannot be negative.
Platform-Dependent: The actual underlying integer type of size_t (e.g., unsigned int, unsigned long, or unsigned long long) is defined by the compiler based on the target system's architecture to ensure it's large enough. 
It is typically 32 bits on a 32-bit system and 64 bits on a 64-bit system.
Purpose-Specific: Using size_t makes the code's intent clear (the variable holds a size or an index) and helps ensure portability across different platforms. 
Common Uses
sizeof Operator: The sizeof operator in C++ returns a value of type size_t.
Array Indexing and Loop Counting: It is the standard type for indexing arrays and other contiguous memory containers.
Standard Library Functions/Containers: Many standard library functions and containers use size_t (or a typedef alias like size_type) for sizes, capacities, and lengths, including:
std::string::length() and std::string::size()
std::vector::size()
Memory management functions like malloc() and memcpy()

#include <iostream>
#include <vector>
#include <cstddef> // Required header for size_t

int main() {
    std::vector<int> data = {10, 20, 30, 40, 50};

    // Use size_t for indexing and size-related operations
    for (std::size_t i = 0; i < data.size(); ++i) {
        std::cout << "Element at index " << i << ": " << data[i] << std::endl;
    }

    // Example of sizeof operator returning size_t
    std::size_t size_of_int = sizeof(int);
    std::cout << "Size of int in bytes: " << size_of_int << std::endl;

    return 0;
}


Key Differences from int
Feature 	                                                          int	                                                                             size_t
Signedness	                                         Signed (can be negative)	                                                                    Unsigned (cannot be negative)
Purpose	                                             General-purpose integer arithmetic	                                                          Representing object sizes and counts in memory
Guaranteed Range	                                   At least 16 bits; often 32 bits	                                             Guaranteed to be large enough for the maximum object size on the platform (typically 32 or 64 bits)
Portability	                                        Can lead to issues on different platforms if range assumptions are made	        Ensures portability when dealing with memory sizes


It is strongly recommended to use std::vector, array, string,smart pointers and other modern C++ constructs to avoid memory leaks.

Your default smart pointer should be unique_ptr. Use shared_ptr only when you really need to share the resource.
Never assign the result of a resource allocation to a raw pointer! Whatever resource allocation method you use, always immediately store the
resource pointer in a smart pointer, either unique_ptr or shared_ptr, or use other RAII classes. RAII stands for Resource Acquisition Is Initialization. An RAII class takes ownership 
of a certain resource and handles its deallocation at the right time.



void couldBeLeaky()
{
Simple* mySimplePtr { new Simple{} };
mySimplePtr-­
>go();
delete mySimplePtr;
}
This function dynamically allocates a Simple object, uses the object, and then properly calls delete. However, you can still have memory leaks in this example! 
If the go() member function throws an exception, the call to delete is never executed, causing a memory leak.

unique_ptr is a generic smart pointer that can point to any kind of memory. That’s why it is a class template, and make_unique() a function template. 
Both require a template parameter between angle brackets, < >, specifying the type of memory you want the unique_ptr to point to.


The following function uses a unique_ptr instead of a raw pointer. The Simple object is not explicitly deleted; but when the unique_ptr instance goes out of scope
(at the end of the function, or because an exception is thrown), it automatically deallocates the Simple object in its destructor.
void notLeaky()
{
auto mySimpleSmartPtr { make_unique<Simple>() };
mySimpleSmartPtr-­>go();
}
This code uses make_unique(), in combination with the auto keyword, so that you only have to specify the type of the pointer, Simple in this case, once. This is the recommended way to cre-
ate a unique_ptr. If the Simple constructor requires parameters, you pass them as arguments to make_unique().

Class template argument deduction (CTAD) can often be used to let the compiler deduce the template type arguments for class templates based on the arguments passed
to a constructor of the class template. For example, it allows you to write vector v{1,2} instead of vector<int> v{1,2}. CTAD does not work with unique_ptr, so you cannot omit the template
type argument.
