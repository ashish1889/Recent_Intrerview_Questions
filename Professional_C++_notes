The following function properly allocates memory for a two-­dimensional array:

char** allocateCharacterBoard(size_t xDimension, size_t yDimension)
{
char** myArray { new char*[xDimension] }; // Allocate first dimension
for (size_t i { 0 }; i < xDimension; ++i) {
myArray[i] = new char[yDimension];
// Allocate ith subarray
}
return myArray;
}


Similarly, when you want to release the memory associated with a multidimensional free store-­based
array, the array delete[] syntax will not clean up the subarrays on your behalf. Your code to release
an array should mirror the code to allocate it, as in the following function:
void releaseCharacterBoard(char**& myArray, size_t xDimension)
{
for (size_t i { 0 }; i < xDimension; ++i) {
delete [] myArray[i];
// Delete ith subarray
myArray[i] = nullptr;
}
delete [] myArray;
// Delete first dimension
myArray = nullptr;
}

In new code, you should use the C++ Standard Library containers such as std::array and vector. For example, use vector<T> for a one-­dimensional dynamic array. For a two-­dimensional dynamic array, you could use
vector<vector<T>>, and similar for higher dimensions.

char* scaryPointer { (char*)7 };

This C++ line, char* scaryPointer { (char*)7 };, declares a character pointer named scaryPointer and initializes it to point to a specific memory address: 7. 
Explanation of the Line
char* scaryPointer: This declares a pointer named scaryPointer that is designed to hold the memory address of a single character or the beginning of a character array.
{ ... }: This uses C++11 uniform initialization syntax.
(char*)7: This is a cast operation. The integer value 7 is explicitly converted into a pointer type (char*). The pointer is therefore assigned the absolute memory address 0x7 (or just 7 in decimal). 
Pitfalls Associated with It
Initializing a pointer to a fixed, low-value memory address like this is fraught with danger in modern programming environments. 
Accessing Invalid Memory (Undefined Behavior): Address 7 is almost certainly not a valid memory location that your application is allowed to read from or write to [1, 2].
Operating System Reservations: Memory addresses near the beginning of the address space (often called the "zero page") are typically reserved by the operating system to 
catch accidental dereferences of NULL pointers or similar errors [1].

Segmentation Faults/Access Violations: Attempting to read from or write to this address (e.g., via *scaryPointer = 'a';) will likely cause your program to crash immediately with a 
segmentation fault or an access violation error, as the OS intervenes to protect system memory [1, 2].
Platform Dependence: The behavior is entirely dependent on the specific system architecture and operating system.
In some embedded systems with no OS, address 7 might be a perfectly valid location, perhaps a control register for a peripheral [1, 2].
On a standard PC (Linux, Windows, macOS), this address is inaccessible to user-level programs. Code relying on this kind of pointer manipulation is not portable [1, 2].
Lack of Purpose (In Modern C++): In standard application development, there is rarely a legitimate reason to manually hardcode an absolute memory address like this. Pointers should point to 
memory dynamically allocated by the program (using new or malloc), or to the address of an existing variable in the program's valid memory space. 
In summary, this line creates a pointer that points into forbidden territory, making it an excellent example of a "scary pointer" that will almost certainly lead to program crashes if used.


Casting with Pointers
Because pointers are just memory addresses (or arrows to somewhere), they are somewhat weakly
typed. A pointer to an XML document is the same size as a pointer to an integer. The compiler lets
you easily cast any pointer type to any other pointer type using a C-­style cast:
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
Of course, using the resulting pointer can result in catastrophic run-­time errors. A static cast offers a
bit more safety. The compiler refuses to perform a static cast on pointers to unrelated data types:
Document* documentPtr { getDocument() };
char* myCharPtr { static_cast<char*>(documentPtr) };// BUG! Won't compile


Instead of passing a C-­style array directly to a function, it is recommended for the function to have a parameter of type std::span, “Standard Library Containers.” span wraps a pointer to an array and its size!


void doubleInts(int* theArray, size_t size)
{
for (size_t i { 0 }; i < size; ++i) { theArray[i] *= 2; }
}
The caller of this function can pass a stack-­based or free store-­based array. In the case of a free store-­ based array, the pointer already exists and is passed by value into the function. In the case of a stack-­
based array, the caller can pass the array variable, and the compiler automatically treats the array variable as a pointer to the array, or you can explicitly pass the address of the first element. All three
forms are shown here:
size_t arrSize { 4 };
int* freeStoreArray { new int[arrSize]{ 1, 5, 3, 4 } };
doubleInts(freeStoreArray, arrSize);
delete [] freeStoreArray;
freeStoreArray = nullptr;
int stackArray[] { 5, 7, 9, 11 };
arrSize = std::size(stackArray);
// Since C++17, requires <array>
//arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-­
C++17, see Ch1
doubleInts(stackArray, arrSize);
doubleInts(&stackArray[0], arrSize);

The parameter-­passing semantics of arrays is uncannily similar to that of pointers, because the compiler treats an array as a pointer when it is passed to a function. A function that takes an array as
an argument and changes values inside the array is actually changing the original array, not a copy. Just like a pointer, passing an array effectively mimics pass-­by-­reference functionality because what
you really pass to the function is the address of the original array, not a copy. The following implementation of doubleInts() changes the original array even though the parameter is an array, not
a pointer:
void doubleInts(int theArray[], size_t size)
{
for (size_t i { 0 }; i < size; ++i) { theArray[i] *= 2; }
}
Any number between the square brackets after theArray in the function prototype is simply ignored.
The following three versions are identical:
void doubleInts(int* theArray, size_t size);
void doubleInts(int theArray[], size_t size);
void doubleInts(int theArray[2], size_t size);


For now, it is enough to know that wide strings support Unicode characters to represent, for example, Japanese strings. The wchar_t type is a character type that can accommodate such Unicode characters, and it is usually
bigger than a char; i.e., it’s more than one byte. To tell the compiler that a string literal is a wide-­string literal, prefix it with an L. For example, suppose you have the following wide string:
const wchar_t* myString { L"Hello, World" };


In C++, size_t is an unsigned integer type used to represent the size of objects in bytes and counts of elements. It is guaranteed to be large enough to hold the size of any object that the system's architecture can handle. 
Key Characteristics
Unsigned: It can only represent non-negative values (zero or positive). This makes sense for sizes and counts, which cannot be negative.
Platform-Dependent: The actual underlying integer type of size_t (e.g., unsigned int, unsigned long, or unsigned long long) is defined by the compiler based on the target system's architecture to ensure it's large enough. 
It is typically 32 bits on a 32-bit system and 64 bits on a 64-bit system.
Purpose-Specific: Using size_t makes the code's intent clear (the variable holds a size or an index) and helps ensure portability across different platforms. 
Common Uses
sizeof Operator: The sizeof operator in C++ returns a value of type size_t.
Array Indexing and Loop Counting: It is the standard type for indexing arrays and other contiguous memory containers.
Standard Library Functions/Containers: Many standard library functions and containers use size_t (or a typedef alias like size_type) for sizes, capacities, and lengths, including:
std::string::length() and std::string::size()
std::vector::size()
Memory management functions like malloc() and memcpy()

#include <iostream>
#include <vector>
#include <cstddef> // Required header for size_t

int main() {
    std::vector<int> data = {10, 20, 30, 40, 50};

    // Use size_t for indexing and size-related operations
    for (std::size_t i = 0; i < data.size(); ++i) {
        std::cout << "Element at index " << i << ": " << data[i] << std::endl;
    }

    // Example of sizeof operator returning size_t
    std::size_t size_of_int = sizeof(int);
    std::cout << "Size of int in bytes: " << size_of_int << std::endl;

    return 0;
}


Key Differences from int
Feature 	                                                          int	                                                                             size_t
Signedness	                                         Signed (can be negative)	                                                                    Unsigned (cannot be negative)
Purpose	                                             General-purpose integer arithmetic	                                                          Representing object sizes and counts in memory
Guaranteed Range	                                   At least 16 bits; often 32 bits	                                             Guaranteed to be large enough for the maximum object size on the platform (typically 32 or 64 bits)
Portability	                                        Can lead to issues on different platforms if range assumptions are made	        Ensures portability when dealing with memory sizes


It is strongly recommended to use std::vector, array, string,smart pointers and other modern C++ constructs to avoid memory leaks.

Your default smart pointer should be unique_ptr. Use shared_ptr only when you really need to share the resource.
Never assign the result of a resource allocation to a raw pointer! Whatever resource allocation method you use, always immediately store the
resource pointer in a smart pointer, either unique_ptr or shared_ptr, or use other RAII classes. RAII stands for Resource Acquisition Is Initialization. An RAII class takes ownership 
of a certain resource and handles its deallocation at the right time.



void couldBeLeaky()
{
Simple* mySimplePtr { new Simple{} };
mySimplePtr-­
>go();
delete mySimplePtr;
}
This function dynamically allocates a Simple object, uses the object, and then properly calls delete. However, you can still have memory leaks in this example! 
If the go() member function throws an exception, the call to delete is never executed, causing a memory leak.

unique_ptr is a generic smart pointer that can point to any kind of memory. That’s why it is a class template, and make_unique() a function template. 
Both require a template parameter between angle brackets, < >, specifying the type of memory you want the unique_ptr to point to.


The following function uses a unique_ptr instead of a raw pointer. The Simple object is not explicitly deleted; but when the unique_ptr instance goes out of scope
(at the end of the function, or because an exception is thrown), it automatically deallocates the Simple object in its destructor.
void notLeaky()
{
auto mySimpleSmartPtr { make_unique<Simple>() };
mySimpleSmartPtr-­>go();
}
This code uses make_unique(), in combination with the auto keyword, so that you only have to specify the type of the pointer, Simple in this case, once. This is the recommended way to cre-
ate a unique_ptr. If the Simple constructor requires parameters, you pass them as arguments to make_unique().

Class template argument deduction (CTAD) can often be used to let the compiler deduce the template type arguments for class templates based on the arguments passed
to a constructor of the class template. For example, it allows you to write vector v{1,2} instead of vector<int> v{1,2}. CTAD does not work with unique_ptr, so you cannot omit the template
type argument.


Before C++17, you had to use make_unique() not only because it meant specifying the type only once, but also because of safety reasons! Consider the following call to a function called foo():
foo(unique_ptr<Simple> { new Simple{} }, unique_ptr<Bar> { new Bar { data() } });
If the constructor of Simple or Bar, or the data() function, throws an exception, depending on your compiler optimizations, it was possible that either a Simple or a Bar object would be leaked. 
With make_unique(), nothing would leak:
foo(make_unique<Simple>(), make_unique<Bar>(data()))
Since C++17, both calls to foo() are safe, but I still recommend using make_unique() as it results in code that is easier to read.
Always use make_unique() to create a unique_ptr.


Smart pointers can still be dereferenced (using * or -­>) just like standard pointers. For example, in the earlier example, the -­> operator is used to call the go() member function:
mySimpleSmartPtr-­>go();
Just as with standard pointers, you can also write this as follows:
(*mySimpleSmartPtr).go();
The get() member function can be used to get direct access to the underlying pointer. This can be useful to pass the pointer to a function that requires a raw pointer. 
For example, suppose you have the following function:
void processData(Simple* simple) { /* Use the simple pointer... */ }
Then you can call it as follows:
processData(mySimpleSmartPtr.get());
You can free the underlying pointer of a unique_ptr and optionally change it to another pointer using reset(). Here’s an example:
mySimpleSmartPtr.reset();
// Free resource and set to nullptr
mySimpleSmartPtr.reset(new Simple{}); // Free resource and set to a new Simple instance


You can disconnect the underlying pointer from a unique_ptr with release() which returns the underlying pointer to the resource and then sets the smart pointer to nullptr. 
Effectively, the smart pointer loses ownership of the resource, and as such, you become responsible for freeing the resource when you are done with it! Here’s an example:
Simple* simple { mySimpleSmartPtr.release() }; // Release ownership
// Use the simple pointer...
delete simple;
simple = nullptr;
Because a unique_ptr represents unique ownership, it cannot be copied! But, spoiler alert, it is possible to move one unique_ptr to another one using move semantics

Sample code for release() method-

#include <iostream>
#include <memory>
using namespace std;
int main()
{
    unique_ptr<int> x{make_unique<int>(2)};
   // cout<<*x;
    int* y{x.release()};
    cout<<*y<<endl;
    if(x == nullptr)
    cout<<"prev pointer released";

    return 0;
}

O/p-
2
prev pointer released


As a sneak preview, the std::move() utility function can be used to explicitly move ownership of a unique_ptr, as in the following code snippet.

class Foo
{
public:
Foo(unique_ptr<int> data) : m_data { move(data) } { }
private:
unique_ptr<int> m_data;
};
auto myIntSmartPtr { make_unique<int>(42) };
Foo f { move(myIntSmartPtr) };

Custom deleters-

Suppose you have a C library that requires you to use my_alloc() for allocation and my_free() for deallocation:
int* my_alloc(int value) { return new int { value }; }
void my_free(int* p) { delete p; }
To properly call my_free() on an allocated resource at the right time, you can use a unique_ptr with a customer deleter:
unique_ptr<int, decltype(&my_free)> myIntSmartPtr { my_alloc(42), my_free };

This code allocates memory for an integer with my_alloc(), and the unique_ptr deallocates the memory by calling the my_free() function. This feature of unique_ptr is also useful to manage
other resources instead of just memory. For example, it can be used to automatically close a file or network socket or anything when the unique_ptr goes out of scope.

decltype is a C++ keyword and type trait operator used to obtain the precise, static type of an expression at compile time. 
It is particularly useful in generic programming (templates) where the types involved might not be known explicitly by the programmer, or when the return type of a 
function depends on its arguments. 

Key Use Cases
Determining the type of an expression:

int x = 5;
decltype(x) y; // y is an int, just like x

Using it within templates (Generic Code):

template <typename T1, typename T2>
auto compose(T1 t1, T2 t2) -> decltype(t1 + t2) {
    return t1 + t2;
}
// The return type is exactly the type that results from adding t1 and t2.

This specific usage is called a "trailing return type" and is very common in modern C++.

Specifying custom deleters for smart pointers: As seen in your original example:

unique_ptr<int, decltype(&my_free)> myIntSmartPtr { my_alloc(42), my_free };

Here, decltype(&my_free) ensures the unique_ptr template is instantiated with the correct function pointer type required to call my_free during cleanup. 
decltype vs. auto
auto is generally used to infer the type of a variable being initialized, often stripping away references and const/volatile qualifiers (decaying the type).
decltype gives you the exact type of the expression, including references (&) and const qualifiers, which is crucial for perfect forwarding and precise type manipulation in advanced C++. 
In essence, decltype allows the compiler to figure out complex types for you, making code cleaner and less error-prone.

