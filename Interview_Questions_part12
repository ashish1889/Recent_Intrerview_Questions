#include <iostream>
#include <thread>
#include <stop_token>
#include <chrono>

using namespace std;

void threadFunction(stop_token token, int id) {
    while (!token.stop_requested()) {
        cout << "Thread " << id << " doing some work." << endl;
        this_thread::sleep_for(500ms);
    }
    cout << "Stop requested for thread " << id << "." << endl;
}

int main() {
    stop_token st;
    thread t1(threadFunction, st, 1);
    thread t2(threadFunction, st, 2);

    // Let the threads run for a few seconds
    this_thread::sleep_for(3s);

    // Request the threads to stop
    st.stop();

    t1.join();
    t2.join();

    cout << "Main thread exiting." << endl;

    return 0;
}



The primary purpose of this function is to simulate a thread performing some work and, importantly, to respond to a "stop" signal. 
This is common in scenarios where you want to be able to gracefully terminate threads, such as when an application is shutting down or a task is no longer needed.

Code Breakdown:

void threadFunction(stop_token token, int id):

void: This indicates that the function doesn't return any value.
threadFunction: This is the name of the function.
stop_token token: This is a crucial part. stop_token is a class (likely from the C++ standard library, specifically <stop_token>) that allows the thread to be signaled to stop its work. 
It represents a token that, when requested to stop, will signal the thread to terminate.
int id: This is an integer that uniquely identifies the thread. This is helpful for logging or debugging, allowing you to distinguish between multiple threads running the same function.
while (!token.stop_requested()) { ... }:

while (!token.stop_requested()): This is the main loop of the thread.
token.stop_requested(): This method of the stop_token object checks if a stop has been requested. It returns true if a stop has been requested, and false otherwise.
!: The ! operator negates the result. So, the loop continues as long as a stop has not been requested. This is the core of the thread's work cycle – it keeps running until it's told to stop.
println("Thread {} doing some work.", id);:

println(...): This is a function call to print a message to the console (or a log). The specific implementation of println isn't shown, but it's assumed to be a standard output function.
"Thread {} doing some work.", id: This is the message being printed. The {} is a placeholder that will be replaced by the value of the id variable. So, the output will be something like "Thread 1 doing some work."
this_thread::sleep_for(500ms);:

this_thread::sleep_for(...): This is a function call to pause the current thread for a specified duration. It's from the <thread> header.
500ms: This specifies the duration to sleep for – 500 milliseconds (half a second). This simulates the thread doing actual work, by pausing for a short period.
println("Stop requested for thread {}.", id);:

This line is executed after the while loop terminates, meaning it's executed only when token.stop_requested() returns true. It prints a message indicating that the thread has received the stop signal.
In essence:

The threadFunction simulates a worker thread that continuously performs a task (printing a message and sleeping) until it receives a stop signal.  
The stop_token mechanism provides a clean and standardized way to request the thread to terminate, allowing it to clean up any resources or finish its current work before exiting.

How it's typically used:

This function would be launched in a separate thread using std::thread (from the <thread> header). Another part of the application would then hold the stop_token and, when it wants to stop the thread,
it would call token.stop() or token.stop_request().

===============================================================================================================================================================================================================================================

 jthread is a relatively recent addition to the C++ standard library (introduced in C++20), designed to simplify and improve thread management, particularly when dealing with tasks that might be stopped or detached. 
It aims to address some of the common pitfalls and complexities associated with traditional thread handling.

1. What problem does jthread solve?

Traditional thread management with std::thread can be cumbersome, especially when you need to ensure proper cleanup of thread resources. Here's a common scenario:

You create a std::thread.
You start a task in that thread.
You need to be able to stop the task (e.g., because of an error or a cancellation request).
You need to ensure that the thread's resources are properly released (e.g., memory is deallocated) even if the task throws an exception or exits unexpectedly.
With std::thread, you'd typically need to use a combination of flags, mutexes, and careful exception handling to manage all of this correctly.  It's easy to make mistakes that can lead to resource leaks or crashes.

jthread simplifies this by providing RAII (Resource Acquisition Is Initialization) semantics.  It automatically manages the thread's lifecycle, ensuring that the thread is properly 
joined or detached when the jthread object goes out of scope, even in the presence of exceptions.

2. Key Features and Benefits of jthread

Automatic Thread Management: The most significant benefit.  The jthread destructor automatically join()s the thread if the thread is still running when the jthread object is destroyed.
If you explicitly detach() the thread, jthread makes sure it’s properly detached. This avoids resource leaks.

Stop Support: jthread provides a request_stop() method that signals the thread to stop its execution.  The thread is responsible for checking this signal and exiting gracefully. 
This is a much cleaner way to request thread termination than using shared flags and manual loop checking.

Exception Propagation: If the thread's function throws an exception, jthread will re-throw that exception in the join() method. This allows you to handle exceptions that occur within the thread in a more centralized way.

Move-Only: jthread is move-only. This means you cannot copy a jthread object.  This is a deliberate design choice to prevent accidental sharing of the underlying thread object, 
which could lead to data races and other problems. You can only transfer ownership of the thread to another jthread using move semantics.

Callable Object: When you construct a jthread, you pass it a callable object (a function, a lambda expression, or an object with an overloaded operator()).  This callable object is the 
function that will be executed in the separate thread.

3. How it Works (Under the Hood - Simplified)

The jthread constructor starts a new thread.
The thread executes the provided callable object.
The jthread object internally maintains a flag to indicate whether the thread has been requested to stop.
The callable object should periodically check the stop_token associated with the jthread (jthread::stop_token).
When the jthread is destroyed, its destructor calls join() on the thread if it's still running. This ensures the thread completes and resources are released. If you explicitly call detach(), the thread is detached.
4. Example

Let's look at a slightly modified version of your original code to illustrate jthread's features:

#include <iostream>
#include <thread>
#include <stop_token>  // Required for jthread

class Calculator
{
public:
    explicit Calculator(int a, int b) : m_a { a }, m_b { b } {}

    void operator()() {
        std::stop_token stop_token; // Get the stop token
        while(!stop_token.stop_requested()){ //Check if stop has been requested
            result = m_a * m_b;
            std::cout << "Calculating...\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

    int getResult() const { return result; }

private:
    int m_a { 0 };
    int m_b { 0 };
    int result { 0 };
};

int main() {
    Calculator calculator { 21, 2 };
    jthread job { ref(calculator) };

    // Simulate some work in the main thread
    std::this_thread::sleep_for(std::chrono::seconds(5));

    // Request the thread to stop
    job.request_stop();

    job.join(); // Wait for the thread to finish

    std::cout << "21*2 = " << calculator.getResult() << std::endl;

    return 0;
}

Key points in this example:

#include <stop_token>: You need to include this header file to use std::stop_token.
std::stop_token stop_token;: This gets the stop token associated with the jthread.
while(!stop_token.stop_requested()): The calculator's operator() now checks stop_token.stop_requested() in a loop. 
When job.request_stop() is called, the stop_token is signaled, and the loop terminates gracefully.
job.request_stop(): This signals the thread to stop.
job.join(): Waits for the thread to complete after the stop request.
5. When to Use jthread

When you need a simple and safe way to manage threads, especially if thread termination is a possibility.
When you want automatic resource management to prevent leaks.
When you need to propagate exceptions from the thread to the main thread.
6. When Not to Use jthread

If you need very fine-grained control over thread attributes (e.g., thread priority). std::thread might be more appropriate in those cases.
If you don't need the automatic stop or exception propagation features. std::thread can be simpler if you just need to run a task in the background 
and don't need to worry about termination or exceptions.
Resources

cppreference.com: https://en.cppreference.com/w/cpp/thread/jthread
C++20 jthread explained: https://www.ibm.com/developerworks/library/cpp-jthread/


======================================================================================================================

Spreadsheet::Spreadsheet(size_t width, size_t height)
: m_width { width }, m_height { height }
{
m_cells = new SpreadsheetCell*[m_width];
for (size_t i { 0 }; i < m_width; ++i) {
m_cells[i] = new SpreadsheetCell[m_height];
}
}


Spreadsheet::Spreadsheet(size_t width, size_t height) ==>
Function Signature: This is the definition of the constructor for the Spreadsheet class. It accepts two arguments: width
and height, both of type size_t (an unsigned integer type used for sizes and array indices).

: m_width { width }, m_height { height } ==>
Initializer List: This is the initializer list. It efficiently initializes the member variables m_width and m_height with
the values passed into the constructor parameters width and height, respectively. This happens before the body of the
constructor executes.

m_cells = new SpreadsheetCell*[m_width]; ==>
Allocate Outer Array (Array of Pointers): The code dynamically allocates an array of pointers. m_cells is assumed to be
a member variable of type SpreadsheetCell**. new SpreadsheetCell*[m_width] creates an array capable of holding width
pointers to SpreadsheetCell objects. Conceptually, this is the first dimension of the 2D grid (the rows).

m_cells[i] = new SpreadsheetCell[m_height]; ==>
Allocate Inner Arrays (The Rows): Inside the loop, for each pointer in the outer array (m_cells[i]), a new array of 
SpreadsheetCell objects is dynamically allocated. This array has a size of height. This creates the second dimension of
the grid (the columns for that specific row).

Key Takeaway on Memory Management
This specific implementation uses C-style raw pointers and manual dynamic memory allocation (new). 
Important Note: When using new in a constructor, you must implement a corresponding destructor (~Spreadsheet()) to 
deallocate this memory using delete[] correctly, or else your program will suffer from memory leaks. Modern C++ practice
would typically use std::vector of std::vector or smart pointers to manage memory automatically

====================================================================================================================================================

An rvalue, on the other hand, is anything that is not an lvalue, such as a literal, or a temporary object or value.
Typically, an rvalue is on the right-­hand side of an assignment operator. For example, take the following statement:
int a { 4 * 2 };
In this statement, a is an lvalue, it has a name, and you can take the address of it with &a. The result
of the expression 4*2, on the other hand, is an rvalue. It is a temporary value that is destroyed when the statement finishes execution. 
In this example, a copy of this temporary value is stored in the variable with name a
If a function returns something by value, the result of calling that function is an rvalue, a temporary.
If the function returns a reference-­to-­non-­const, then the result of calling the function is an lvalue, as
you will be able to use the result on the left-­hand side of an assignment.








